"""
客户端程序的代码与此类似,客户端采用循环不断地读取用户的键盘输入内容,每当读取到用户输入的内容后,就将该内容通过数据报发送出去;
接下来再读取来自 socket 中的信息(也就是来自服务器端的数据)。客户端程序的代码如下。
"""
import socket

PORT = 30000
# 定义每个数据报的大小最大为4KB
DATA_LEN = 4096
DEST_IP = "192.168.1.88"
# 通过type属性指定创建基于UDP协议的socket
s = socket.socket(type=socket.SOCK_DGRAM)
# 不断地读取键盘输入
while True:
    line = input('')
    if line is None or line == 'exit':
        break
    data = line.encode('utf-8')
    # 发送数据报
    s.sendto(data, (DEST_IP, PORT))
    # 读取socket中的数据
    data = s.recv(DATA_LEN)
    print(data.decode('utf-8'))
s.close()
"""
上面程序中的粗体字代码就是使用 UDP 协议的 socket 发送和接收数据报的关键代码,这些代码与服务器端程序的代码基本相似。
而客户端与服务器端的唯一区别在于：服务器端的IP 地址和端口是固定的,所以客户端可以直接将数据报发送给服务器端;
而服务器端则需要根据所接收到的 数据报来决定"反馈"数据报的目的地。

读者可能会发现,在使用 UDP 协议进行网络通信时,服务器端无须也无法保存每个客户端的状态,客户端把数据报发送到服务器端后,
完全有可能立即退出。但不管客户端是否退出,服务器 端都无法知道客户端的状态。

当使用 UDP 协议时,如果想让一个客户端发送的聊天信息被转发到其他所有的客户端也是可以的,
程序可以考虑在服务器端使用 list 列表来保存所有的客户端信息,每当接收到一个客户端的数据报之后,
程序检查该数据报的来源地址是否在 list 列表中,如果不在就将该来源地址添加到 list 列表中。
这样又涉及一个问题：可能有些客户端发送一个数据报之后,永久地退出了程序,但服务器端依然会将该客户端的IP 地址和端口保存在list列表中。
因此,程序还需要定义一个定时器,定期检查每个客户端有多长时间没向服务器端发送数据了,
如果超过一定的时间(比如10分钟)该客户端还没有发送数据,则服务器端就将该客户端的 IP 地址和端口从list列表中删除 ……
总之, 这种方式需要处理的问题比较多,编程比较烦琐。幸好 UDP 协议还支持多点广播,Python 也为 UDP 协议的多点广播提供了支持。
"""