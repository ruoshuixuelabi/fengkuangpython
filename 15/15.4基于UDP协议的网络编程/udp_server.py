"""
15.4	基于UDP协议的网络编程

UDP 是一种不可靠的网络协议,它在通信实例的两端各建立一个 socket,但这两个 socket 之间并没有虚拟链路,
它们只是发送、接收数据报的对象。Python 同样使用 socket 模块来支持基于 UDP 协议的通信。

15.4.1 UDP协议基础

UDP(User Datagram Protocol,用户数据报协议)主要用来支持那些需要在计算机之间传输数据的网络连接。
UDP 协议从问世至今已经被使用了很多年,虽然目前 UDP 协议的应用不如 TCP 协议广泛,但 UDP 依然是一种非常实用和可行的网络传输层协议。
尤其是在一些实时性很强的应用场景中,比如网络游戏、视频会议等,UDP 协议的快速能力更具有独特的魅力。

UDP 是一种面向非连接的协议,面向非连接指的是在正式通信前不必与对方先建立连接,不管对方状态就直接发送数据。
至于对方是否可以接收到这些数据,UDP 协议无法控制,所以说 UDP 是一种不可靠的协议。
UDP 协议适用于一次只传送少量数据、对可靠性要求不高的应用环境。

与前面介绍的 TCP 协议一样,UDP 协议直接位于 IP 协议之上。实际上,IP 协议属于OSI 参考模型的网络层协议,
而 UDP 协议和TCP 协议都属于传输层协议。

因为 UDP 是面向非连接的协议,没有建立连接的过程,因此它的通信效率很高;但也正因为如此,它的可靠性不如 TCP 协议。

UDP 协议的主要作用是完成网络数据流和数据报之间的转换——
在信息的发送端,UDP 协议将网络数据流封装成数据报,然后将数据报发送出去;在信息的接收端,UDP 协议将数据报转换成实际数据内容。

提示：可以认为UDP 协议的 socket 类似于码头,数据报则类似于集装箱。码头的作用就是负责发送、接收集装箱,
而 socket 的作用则是发送、接收数据报。因此,对于基于 UDP 协议的通信双方而言,没有所谓的客户端和服务器端的概念

UDP 协议和 TCP 协议简单对比如下。
TCP 协议：可靠,传输大小无限制,但是需要连接建立时间,差错控制开销大。
UDP 协议：不可靠,差错控制开销较小,传输大小限制在64KB 以下,不需要建立连接。

15.4.2	使用socket发送和接收数据

程序在创建 socket 时,可通过 type 参数指定该 socket 的类型,如果将该参数指定为SOCK_DGRAM,则意味着创建基于 UDP 协议的socket。

在创建了基于 UDP 协议的 socket 之后,程序可以通过如下两个方法来发送和接收数据。
(1)socket.sendto(bytes,address): 将 bytes数据发送到address地址。
(2)socket.recvfrom(bufsize[,flags]): 接收数据。该方法可以同时返回socket中的数据和数据来源地址。

从这两个方法的介绍可以看出,使用 UDP 协议的 socket 在发送数据时必须使用 sendto() 方法,
这是因为程序必须指定发送数据的目标地址(通过address参数指定);使用 UDP 协议的 socket 在接收数据时,既可使用普通的 recv()方法,
也可使用 recvfrom()方法。如果程序需要得到数据报的来源,则应该使用recvfrom()方法。

从上面的介绍不难看出,由于 UDP 协议没有建立虚拟链路,因此程序使用 socket 发送数据报时,
scoket 并不知道将该数据报发送到哪里,必须通过 sendto() 方法的 address 参数来指定数据报的目的地,
这个目的地的地址会被附加在所发送的数据报上。就像码头并不知道每个集装箱的目的地一样,
码头只是将这些集装箱发送出去,而集装箱本身包含了该集装箱的目的地。

程序在使用 UDP 协议进行网络通信时,实际上并没有明显的服务器端和客户端,因为双方都需要先建立一个socket对象,用来接收或发送数据报。
但在实际编程中,通常具有固定 IP 地址和端口的 socket 对象所在的程序被称为服务器,
因此该 socket 应该调用bind()方法被绑定到指定IP 地址和端口,这样其他socket (客户端socket)才可向服务器端socket
(绑定了固定IP 地址和端口 的 socket)发送数据报,而服务器端socket就可以接收这些客户端数据报。

当服务器端(也可以是客户端)接收到一个数据报后,如果想向该数据报的发送者"反馈"一些信息,此时就必须获取数据报的"来源信息",
这就到了recvfrom()方法"闪亮登场"的时候,该方法不仅可以获取 socket 中的数据,也可以获取数据的来源地址,
程序就可以通过该来源地址来"反馈"信息。

一般来说,服务器端socket的 IP 地址和端口应该是固定的,因此客户端程序可以直接向服务器端socket发送数据;
但服务器端无法预先知道各客户端socket的 IP 地址和端口,因此必须调用 recvfrom()方法来获取客户端socket的 IP 地址和端口。

下面程序使用 UDP 协议的 socket 实现了C/S 结构的网络通信。
本程序的服务器端通过循环1000 次来读取 socket 中的数据报,每当读取到内容之后,便向该数据报的发送者发送一条信息。
服务器端程序的代码如下。
"""
import socket

PORT = 30000;
# 定义每个数据报的大小最大为4KB
DATA_LEN = 4096;
# 定义一个字符串数组,服务器端发送该数组的元素
books = ("疯狂Python讲义", "疯狂Kotlin讲义", "疯狂Android讲义", "疯狂Swift讲义")
# 通过type属性指定创建基于UDP协议的socket
s = socket.socket(type=socket.SOCK_DGRAM)
# 将该socket绑定到本机的指定IP和端口
s.bind(('192.168.1.88', PORT))
# 采用循环接收数据
for i in range(1000):
    # 读取s中的数据的数据的发送地址
    data, addr = s.recvfrom(DATA_LEN)
    # 将接收到的内容转换成字符串后输出
    print(data.decode('utf-8'))
    # 从字符串数组中取出一个元素作为发送数据
    send_data = books[i % 4].encode('utf-8')
    # 将数据报发送给addr地址
    s.sendto(send_data, addr)
s.close()
"""
上面程序中的粗体字代码就是使用 UDP 协议的 socket 发送和接收数据报的关键代码,该程序可以接收1000个客户端发送过来的数据。
"""