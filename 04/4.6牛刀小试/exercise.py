"""
4.6.2 绕圈圈
下面是来自某知名公司的一道"面试题"。
给定4,应该输出如下形式的数据。
01121110
02131609
03141508
04050607
给定5,应该输出如下形式的数据。
0116151413
0217242312
0318252211
0419202110
0506070809
仔细观察上面的试题,不难发现程序就是"绕圈圈"填入整数,如图4.2所示。
掌握上面的规律之后,我们打算使用列表嵌套列表(相当于二维列表)的方式来存储这些整数,
将数值存入嵌套列表时需要遵守这种"绕圈圈"的规则,然后再以二维方式将这个嵌套列表打印出 来。
为了控制"绕圈",该程序的关键点就是控制绕圈的拐弯点。在图4.2中标出的对角线上的位置,就是重要的拐弯点。
找到图中①②③号转弯线之后,可以发现如下规则。
(1)位于①号转弯线的行索引与列索引总和为n-1 (即给定整数值减1)。
(2)位于②号转弯线的行索引与列索引相等。
(3)位于③号转弯线的行索引等于列索引减1。
总结出上面的规则之后,接下来就可实现如下程序。
"""

SIZE = 7
array = [[0] * SIZE]
# 创建一个长度SIZE * SIZE的二维列表
for i in range(SIZE - 1):
    array += [[0] * SIZE]
# 该orient代表绕圈的方向
# 其中0代表向下,1代表向右,2代表向左,3代表向上
orient = 0
# 控制将1~SIZE * SIZE的数值填入二维列表中
# 其中j控制行索引,k控制列索引
j = 0
k = 0
for i in range(1, SIZE * SIZE + 1):
    array[j][k] = i
    # 如果位于图4.2中①号转弯线上
    if j + k == SIZE - 1:
        # j>k,位于左下角
        if j > k:
            orient = 1
        # 位于右上角
        else:
            orient = 2
    # 如果位于图5.2中②号转弯线上
    elif (k == j) and (k >= SIZE / 2):
        orient = 3
    # 如果j位于图5.2中③号转弯线上
    elif (j == k - 1) and (k <= SIZE / 2):
        orient = 0
    # 根据方向来控制行索引、列索引的改变
    # 如果方向为向下绕圈
    if orient == 0:
        j += 1
    # 如果方向为向右绕圈
    elif orient == 1:
        k += 1
    # 如果方向为向左绕圈
    elif orient == 2:
        k -= 1
    # 如果方向为向上绕圈
    elif orient == 3:
        j -= 1
# 采用遍历输出上面的二维列表
for i in range(SIZE):
    for j in range(SIZE):
        print('%02d ' % array[i][j], end="")
    print("")
