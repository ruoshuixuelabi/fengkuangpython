"""
16.4 单元测试

单元测试是一种比较特别的测试,与其他测试通常由测试人员来完成不同,单元测试可以由开发人员来完成。
尤其是借助 xUnit 测试框架,开发人员往往在开发软件的同时也完成了单元测试。

16.4.1 单元测试概述

单元测试是一种小粒度的测试,用以测试某个功能或代码块。单元测试既可由程序开发者来完成,也可由专业的软件测试人员来完成。
由于单元测试属于难度较大的白盒测试,往往需要知道程序内部的设计和编码的细节才能进行测试,因此有些公司直接让开发人员进行单元测试。
如果需要让软件测试人员来完成单元测试,那么这些软件测试人员必须有一定的编程功底,甚至拥有编程经验,
只有这样才能先去了解程序内部的设计和编码的细节。

单元测试的好处如下。
(1)提高开发速度：借助专业的测试框架,单元测试能以自动化方式执行,从而提高开发者开发、测试的执行效率。
(2)提高软件代码质量：单元测试使用小版本发布、集成,有利于开发人员实时除错,同时引入系统重构的理念,从而使代码具有更高的可扩展性。
(3)提升系统的可信赖度：单元测试可作为一种回归测试,支持在修复或更正后进行"再测试",从而确保代码的正确性。

单元测试的主要被测对象包括：
(1)结构化编程语言中的函数。
(2)面向对象编程语言中的接口、类、对象。

单元测试的任务主要包括：
(1)被测单元的接口测试。
(2)被测单元的局部数据结构测试。
(3)被测单元的边界条件测试。
(4)被测单元中的所有独立执行路径测试。
(5)被测单元中的各条错误处理路径测试。

被测单元的接口测试指的是它与其他程序单元的通信接口,比如调用方法的方法名、形参等。
接口测试是单元测试的基础,只有在数据能正确输入、输出的前提下,其他测试才有意义。测试接口正确与否应该考虑下列因素。
(1)输入的实参与形参的个数、类型是否匹配。
(2)调用其他程序单元(如方法)时所传入实参的个数、类型与被调用程序单元的形参的个数、类型是否匹配。
(3)是否存在与当前入口点无关的参数引用。
(4)是否修改了只读型参数。
(5)是否把某些约束也作为参数传入了。

如果被测程序单元还包含来自外部的输入/输出,则还需要考虑如下因素。
(1)打开的输入/输出流是否正确。
(2)是否正常打开、关闭了输入/输出流。
(3)格式说明与输入/输出语句是否匹配。
(4)缓冲区大小与记录长度是否匹配。
(5)文件在使用前是否已经打开。
(6)是否处理了文件尾。
(7)是否处理了输入/输出错误。

接下来,单元测试应该从被测程序单元的内部进行分析,主要保证被测程序单元内部的局部变量在程序执行过程中是正确的、完整的。
局部变量往往是错误的根源,应仔细设计测试用例,力求发现下面几类错误。
(1)不合适或不兼容的类型声明。
(2)没有为局部变量指定初值。
(3)局部变量的初值或默认值有错。
(4)局部变量名出错(包括手误拼错或不正确的截断)。
(5)出现上溢、下溢和地址异常。

除局部变量之外,如果被测程序单元还与程序中的全局变量耦合,那么在进行单元测试时还应 该查清全局变量对被测单元的影响。

除此之外, 一个健壮的程序单元不仅可以应付各种正确的情形,还可以预见各种出错的情况, 并针对出错情况进行处理。
因此,软件测试也应该对这些错误处理进行测试,这种测试应着重检查下列问题。
(1)输出的出错信息是否易于理解、调试。
(2)记录的错误信息与实际遇到的错误是否相符。
(3)异常处理是否合适。
(4)在错误信息中是否包含足够的出错定位信息。

Python 为单元测试提供了 PyUnit(由unittest包负责提供),它是广大xUnit家族成员(包括 JUnit、CppUnit等)之一,
通过使用 PyUnit,开发人员可以非常方便地为函数、类提供配套的、可复用的单元测试。

16.4.2	单元测试的逻辑覆盖

从单元测试的用例设计来看,最基本、最简单的方法就是边界值分析。所谓边界值分析,
指的是测试经验表明大量的错误都发生在输入/输出范围的边界条件上,而不是某个范围的内部。
因此往往针对边界值及其左、右来设计测试用例,很有可能发现新的缺陷。

接下来的测试可以对被测单元的内部执行进行逻辑覆盖。单元测试的逻辑覆盖包括：
(1)语句覆盖—— 每条语句都至少执行一次。
(2)判定(边)覆盖—— 每条语句都执行,每个判定的所有可能结果都至少执行一次。
(3)条件覆盖—— 每条语句都执行,判定表达式的每种可能都取得各种结果。
(4)判定-条件覆盖—— 同时满足判定覆盖和条件覆盖,每个判定条件的各种可能组合都至少出现一次。
(5)路径覆盖——程序的每条可能路径都至少执行一次。

1. 语句覆盖
设计若干测试用例,执行被测程序,使得每条可执行语句都至少执行一次。语句覆盖是最弱的逻辑覆盖准则。
下面是一段非常简单的Python代码。

的真假值均得到满足。判定覆盖又称为分支覆盖。

仍以上面的代码为例,选用的两个测试用例如下。
用例 1 :a=20;b=0;m=3,    通过路径ACE, 也就是让两个判定条件都取真值。
用例 2 : a=10;b=0;m=3,    通过路径ABD, 也就是让两个判定条件都取假值,从而使两
个判断的4个分支C、E 和 B、D 分别得到覆盖。
也可以选用另外两个测试用例,如下所示。
用 例 3 :a=12;b=0;m=3,    通过路径ACD。
用 例 4 : a=20;b=1;m=1,    通过路径ABE, 同样也可覆盖4个分支。
上述两组测试用例不仅满足了语句覆盖,而且还做到了判定覆盖。
3. 条件覆盖
设计若干测试用例,执行被测程序,使得每个判断中每个条件的可能取值都至少满足一次。 在上面的代码中,所有条件一共包含如下几种情况。
(1)a>10,  取真值,记为T1。
(2)a>10,  取假值,即a<=10, 记为F1。
(3)b==0,  取真值,记为T2。
(4)b==0,  取假值,即b!=0,  记为F2。
(5)a==20,  取真值,记为T3。
(6)a==20,  取假值,即a!=20, 记为F3。
(7)m>15,   取真值,记为T4。
(8)m>15,   取假值,即m<=15,  记为F4。
表16.1给出了3个测试用例。
表16.1 测试用例

测试用例	a,b,m	通过路径	覆盖条件
用例1	20.0.1	ACE	T1,T2.T3,T4
用例2	5,0.2	ABD	F1,T2,F3,F4
用例3	20,1.5	ABE	T1,F2,T3,F4
从表16.1中可以看到,3个测试用例覆盖了4个条件的8种情况。进一步分析表16.1发现,3 个测试用例也把两个判断的4个分支B、C、D 和E 都覆盖了。这是否意味着做到了条件覆盖,也 就必然实现了判定覆盖?
假设选用表16.2所示的两个测试用例。
表16.2 测试用例

a,b,m


上面这种覆盖情况表明,满足条件覆盖的测试用例不一定满足判定覆盖。正如从表16.2中所 看到的,这两个测试用例做到了条件覆盖,但其只覆盖了4个分支中的两个。为了解决这一矛盾, 需要对条件和分支兼顾,这种覆盖被称为判定-条件覆盖。
4. 判定-条件覆盖
判定-条件覆盖要求设计足够多的测试用例,使得判断中每个条件所有可能的组合都至少出现 一次,并且每个判断本身的判定结果也至少出现一次。示例中两个判断各包含两个条件,如下所示。
(1)a>10,b==0,   记作T1,T2。
(2)a>10,b!=0,   记作T1,F2。
(3)a<=10,b=0,
(4)a<=10,b!=0,
(5)a==20,m>1,
(6)a=20,m<=1,
(7)a!=20,m>1,
(8)a!=20,m<=1,


记作F1,T2;
记作F1,F2。
记 作T3,T4。
记 作T3,F4。
记作F3,T4。
记作F3,F4。

选用的4个测试用例如表16.3所示。
表16.3 测试用例

测试用例	a,b,m	通过路径	覆盖组合号	覆盖条件
用例1	20,0.3	ACE	(1)(5)	T1,T2,T3,T4
用例2	20,1.10	ABC	(2)(6)	T1.F2,T3,F4
用例3	10,0,20	ABE	(3)(7)	F1,T2,F3,T4
用例4	1.2.3	ABD	(4)(8)	F1,F2,F3,F4
上面的代码共有4条路径,以上4个测试用例覆盖了条件组合,同时也覆盖了4个分支。路径 ACD 没有被测试。

5. 路径覆盖
路径覆盖要求设计足够多的测试用例,覆盖程序中所有可能的路径。示例中有4条可能路径
ACE、ABD、ABE   和 ACD。
下面设计4个测试用例,分别覆盖这4条路径,如表16.4所示。
表16.4 测试用例

测试用例	a.b.m	通过路径
用例1	20,0,3	ACE
用例2	5.0.2	ABD
用例3	20,1,10	ABE
用例4	12,0,7	ACD
由于上面的代码非常短,只有4条可能的路径,但在实际测试中代码要复杂得多。因此,在实 际测试中做到路径覆盖的可能性并不大。
通常在实际测试中,基本要求是做到判定覆盖即可。因此,随着覆盖级别的提升,软件测试的 测试成本也会大幅度提高。实用的测试策略应该是测试效果和测试成本的折中选择。而且,即使选 择最严格的测试流程,选择最高级别的覆盖,也不能保证程序的正确性。
测试的目的不是要证明程序的正确性,而是要尽可能找出程序中的缺陷。没有完备的测试方法, 也就没有完备的测试活动。
"""


def test(a, b, m):
    if a > 10 and b == 0:
        m = a + b
    if a == 20 or m > 15:
        m += 1
