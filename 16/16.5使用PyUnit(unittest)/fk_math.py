"""
PyUnit 是 Python 自带的单元测试框架,用于编写和运行可重复的测试。PyUnit 是 xUnit 体系的一个成员,xUnit是众多测试框架的总称,
PyUnit 主要用于进行白盒测试和回归测试。

提示：如果你使用的是2.1或更早版本的 Python,则可能需要自行下载和安装 PyUnit。现在的开发者通常不需要操心这些事情。

通过 PyUnit 可以让测试具有持久性,测试与开发同步进行,测试代码与开发代码一同发布。使用PyUnit具有如下好处。
(1)可以使测试代码与产品代码分离。
(2)针对某一个类的测试代码只需要进行较少的改动,便可以应用于另一个类的测试。
(3) PyUnit 开放源代码,可以进行二次开发,方便对 PyUnit 的扩展。

PyUnit是一个简单、易用的测试框架,其具有如下特征。
(1)使用断言方法判断期望值和实际值的差异,返回bool值。
(2)测试驱动设备可使用共同的初始化变量或实例。
(3)测试包结构便于组织和集成运行。

16.5.1 PyUnit(unittest)的用法

所有测试的本质其实都是一样的：通过给定参数来执行函数,然后判断函数的实际输出结果和期望输出结果是否一致。

PyUnit 测试与其他 xUnit 的套路一样：基于断言机制来判断函数或方法的实际输出结果和期望输出结果是否一致,
测试用例提供参数来执行函数或方法,获取它们的执行结果,然后使用断言方法来判断该函数或方法的输出结果与期望输出结果是否一致,
如果一致则说明测试通过;如果不一致则说明测试不通过。

目前还有一种流行的开发方式叫作测试驱动开发,这种方式强调先编写测试用例,然后再编写函数和方法。
假如程序要开发满足 A 功能的 fun_a()函数,采用测试驱动开发的步骤如下。
①为fun_a() 函数编写测试用例,根据业务要求,使用大量不同的参数组合来执行 fun_a()函数,
并断言该函数的执行结果与业务期望的执行结果匹配。
②编写、修改 fun_a() 函数。
③运行fun_a() 函数的测试用例,如果测试用例不能完全通过;则重复第2步和第3步,直到 fun a()的所有测试用例全部通过。

测试驱动开发强调结果导向：在开发某个功能之前,先定义好该功能的最终结果(测试用例关 注函数的执行结果),然后再去开发该功能。
就像建筑工人在砌墙之前,要先拉好一根笔直的绳子(作用相当于测试用例),然后再开始砌墙——这样砌出来的墙就会符合标准。
所以说测试驱动开发确实是一种不错的开发方式。

下面开发一个简单的 fk_math.py 程序,该程序包含两个函数,分别用于计算一元一次方程的解和二元一次方程的解。
"""


def one_equation(a, b):
    """
    求一元一次方程a * x + b = 0的解
    参数a - 方程中变量的系数
    参数b - 方程中的常量
    返回 方程的解
    """
    # 如果a = 0,则方程无法求解
    if a == 0:
        raise ValueError("参数错误")
    # 返回方程的解
    else:
        #        return -b / a  # ①
        return b / a


def two_equation(a, b, c):
    """
    求一元二次方程a * x * x + b * x + c = 0的解
    参数a - 方程中变量二次幂的系数
    参数b - 方程中变量的系数
    参数c - 方程中的常量
    返回 方程的根
    """
    # 如果a == 0,变成一元一次方程
    if a == 0:
        raise ValueError("参数错误")
    # 有理数范围内无解
    elif b * b - 4 * a * c < 0:
        raise ValueError("方程在有理数范围内无解")
    # 方程有唯一的解
    elif b * b - 4 * a * c == 0:
        # 使用数组返回方程的解
        return -b / (2 * a)
    # 方程有两个解
    else:
        r1 = (-b + (b * b - 4 * a * c) ** 0.5) / 2 / a
        r2 = (-b - (b * b - 4 * a * c) ** 0.5) / 2 / a
        # 方程的两个解
        return r1, r2
