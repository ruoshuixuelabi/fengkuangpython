"""
所谓文档测试,指的是通过 doctest 模块运行 Python 源文件的说明文档中的测试用例,从而生成测试报告。

前面在查看 Python 的模块文档时,经常会看到如下信息。
os.path.commonprefix(['/usr/lib','/usr/local/lib'])
'/usr/1'
os.path.commonpath(['/usr/lib','/usr/local/lib'])
'/usr'

用户完全可以将这些代码拷贝到 Python 的交互式解释器中运行,然后可以看到运行结果与文档中示例代码的输出结果完全一致。

上面的说明就是文档测试的注释,文档测试工具可以提取说明文档中的测试用例,其中">>>"之后的内容表示测试用例,
接下来的一行则代表该测试用例的输出结果。文档测试工具会判断测试用例的运行结果与输出结果是否一致,如果不一致就会显示错误信息。

现在定义一个简单的模块,该模块包含一个函数和一个类,程序为该函数和该类提供了说明文档,该文档中包含了测试用例。程序代码如下。
"""


def square(x):
    """
    一个用于计算平方的函数

    例如
    >>> square(2)
    4
    >>> square(3)
    9
    >>> square(-3)
    9
    >>> square(0)
    0
    """
    #    return x * 2 # ①、故意写错的
    return x ** 2  # 修改正确


class User:
    """
    定义一个代表用户的类,该类包含如下两个属性：
    name - 代表用户的名字
    age - 代表用户的年龄

    例如
    >>> u = User('fkjava', 9)
    >>> u.name
    'fkjava'
    >>> u.age
    9
    >>> u.say('i love python')
    'fkjava说: i love python'
    """

    def __init__(self, name, age):
        #        self.name = 'fkit' # ②、故意写错的
        self.name = name  # 修改正确
        self.age = age

    def say(self, content):
        return self.name + '说: ' + content


if __name__ == '__main__':
    import doctest

    doctest.testmod()
"""
上面第一段粗体字代码就是程序为 square() 函数提供的测试用例,在文档中一共为该函数提供了4个测试用例;
第二段粗体字代码是程序为 User 类提供的测试用例,在文档中一共为该类提供了3个测试用例,分别用于测试用户的name、age 和 say()方法。

最后一段粗体字代码进行了判断,如果是直接使用 python 命令来运行该程序(__name__ == '__main__),
程序将导入doctest模块,并调用该模块的testmod()函数。

从上面程序可以看到,Python 为文档测试提供了doctest模块,该模块的用法非常简单,程序只要调用该模块的 testmod() 函数即可。
运行上面程序,可以看到如下输出结果。

从上面的输出结果可以看出,一共有 4 个测试没有通过——在 User 类中有两个测试没有通过;在square()函数中有两个测试没有通过。
这是因为上面程序中①②两行代码故意写错了,其中①号 代码用于计算x的平方,应该写成x**2,但漏写了一个星号;
②号代码则应该用传入的name 参 数对selfname 赋值。

上面显示的测试输出结果也很清晰,每个测试用例结果都包含如下4部分。
第一部分：显示在哪个源文件的哪一行。
第二部分：Failed example,显示是哪个测试用例出错了。
第三部分：Expected, 显示程序期望的输出结果。也就是在">>>命令"的下一行给出的 运行结果,它就是期望结果。
第四部分：Got,显示程序实际运行产生的输出结果。只有当实际运行产生的输出结果与期望结果一致时,才表明该测试用例通过。

将上面程序中①②两行代码修改正确,再次使用 python 命令来运行该程序,将看不到任何输出结果——说明文档测试中的所有测试用例都通过了。

由此可见,Python 为文档注释提供了doctest模块,该模块的用法非常简单,程序只要导入该模块,并调用该模块的testmod()函数即可。
testmod()函数会自动提取该模块的说明文档中的测试用例,并执行这些测试用例,最终生成测试报告。
如果存在没有通过的测试用例,程序就会显示有多少个测试用例没有通过;如果所有测试用例都能通过测试,则不生成任何输出结果。
"""
