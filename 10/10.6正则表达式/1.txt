
10.6.2	正则表达式旗标

Python 支持的正则表达式旗标都使用该模块中的属性来代表,这些旗标如下所示。
(1)re.A 或 re.ASCII：该旗标控制\w,\W,\b,\B,\d,\D,\s和\S只匹配 ASCII 字符,而不匹配所有的 Unicode 字符。
也可以在正则表达式中使用(?a)行内旗标来代表。
(2)re.DEBUG：显示编译正则表达式的 Debug 信息。没有行内旗标。
(3)re.I 或 re.IGNORECASE：使用正则表达式匹配时不区分大小写。对应于正则表达式中的(?i)行内旗标。

#默认区分大小写,所以无匹配
re.findall(r'fkit','FkIt  is a good  domain,FKIT is good')
[]
使用 re.I 指定不区分大小写
re.findall(r'fkit','FkIt  is a good  domain,FKIT is good',re.I)
['FkIt','EKIT']

(4)re.L 或 re.LOCALE：根据当前区域设置使用正则表达式匹配时不区分大小写。
该旗标只能对 bytes 模式起作用,对应于正则表达式中的(?L)行内旗标。
(5)re.M 或 re.MULTILINE：多行模式的旗标。当指定该旗标后,"^"能匹配字符串的开头和每行的开头(紧跟在每一个换行符的后面);
"$"能匹配字符串的末尾和每行的末尾(在每一个换行符之前)。在默认情况下,"^"只匹配字符串的开头,"$"只匹配字符串的结尾,
或者匹配到字符串默认的换行符(如果有)之前。对应于正则表达式中的(?m)行内旗标。
(6)re.S 或 s.DOTALL：让点(.)能匹配包括换行符在内的所有字符,如果不指定该旗标,则点(.)能匹配不包括换行符的所有字符。
对应于正则表达式中的(?s)行内旗标。
(7)re.U 或 re.Unicode：该旗标控制\w,\W,\b,\B,\d,\D,\s和\S 能匹配所有的Unicode 字符。
这个旗标在Python 3.x中完全是多余的,因为 Python 3.x 默认就是匹配所有的 Unicode 字符。
(8)re.X 或 re.VERBOSE：通过该旗标允许分行书写正则表达式,也允许为正则表达式添加注释,从而提高正则表达式的可读性。
对应于正则表达式中的(?x)行内旗标。
例如,下面两个正则表达式都可匹配广州的座机号码,它们是完全一样的。
a = re.compile(r"""020  # 广州的区号
\-      # 中间的短横线
\d(8) #8个数值""", re.X)
b = re.compile(r'020\-\d(8)')

上面的a在编译正则表达式时使用了re.X旗标,这意味着该正则表达式可以换行,也可以添加注释,这样该正则表达式就更容易阅读和理解了

10.6.3 创建正则表达式

前面已经介绍了,正则表达式就是一个用于匹配字符串的模板,它可以匹配一批字符串,所以创建正则表达式就是创建一个特殊的字符串。
正则表达式所支持的合法字符如表10.5所示。
表10.5 正则表达式所支持的合法字符
字符	                        解释
x	                            字符x(x可代表任意合法的字符)
\uhhhh	                十六进制值0xhhhh所表示的Unicode字符
\t	                            制表符('u0009')
\n	                        新行(换行)符('u000A')
\r	                            回车符('u000D')
\f	                            换页符('u000C')
\a	                            报警(bell)符(\u0007')
\e	                            Escape符('u001B')
\cx	                        x对应的控制符。例如,\cM匹配Ctrl+M。x值必须为 A~Z 或 a~z 之一

除此之外,正则表达式中有一些特殊字符,这些特殊字符在正则表达式中有其特殊的用途,比如前面介绍的反斜线(\)。
如果需要匹配这些特殊字符,就必须先将这些字符转义,也就是在前面添加一个反斜线(\)。正则表达式中的特殊字符如表10.6所示。
表10.6 正则表达式中的特殊字符

特殊字符	                说明
$                              匹配一行的结尾。要匹配$字符本身,请使用\$
^	                            匹配一行的开头。要匹配 ^ 字符本身,请使用\^
()	                            标记子表达式(也就是组)的开始位置和结束位置。要匹配这些字符,请使用\(和\)
[]	                            用于确定中括号表达式的开始位置和结束位置。要匹配这些字符,请使用\[和\]
{}	                            用于标记前面子表达式的出现频度。要匹配这些字符,请使用\{和\}
*	                            指定前面子表达式可以出现零次或多次。要匹配*字符本身,请使用\*
+	                            指定前面子表达式可以出现一次或多次。要匹配+字符本身,请使用\+
?	                            指定前面子表达式可以出现零次或一次。要匹配?字符本身,请使用\?
.	                            匹配除换行符\n之外的任意单个字符。要匹配.字符本身,请使用\.
\	                            用于转义下一个字符,或指定八进制、十六进制字符。如果需匹配\字符,请使用\\
|	                            指定在两项之间任选一项。如果要匹配 | 字符本身,请使用\|

将上面多个字符拼起来,就可以创建一个正则表达式。例如：

print(re.fullmatch(r'\u0041\\','A\\'))# 匹配A\
<re.Match object; span=(0, 2), match='A\\'>
print(re.fullmatch(r'\u0061\t','a\t'))   匹配a<制表符>
<re.Match object; span=(0, 2), match='a\t'>
print(re.fullmatch(r'\?\[','?['))#// 匹配?[
<re.Match object; span=(0, 2), match='?['>

上面的正则表达式依然只能匹配单个字符,这是因为还未在正则表达式中使用通配符,通配符是可以匹配多个字符的特殊字符。
正则表达式中的通配符的功能远远超出了普通通配符的功能,它被称为"预定义字符"。正则表达式支持如表10.7所示的预定义字符。
表10.7 正则表达式所支持的预定义字符

预定义字符	说 明
.	                默认可匹配除换行符之外的任意字符,在使用 re.S 或 s.DOTALL 旗标之后,它还可匹配换行符
\d	            匹配0~9的所有数字
\D	            匹配非数字
\s              	匹配所有的空白字符,包括空格、制表符、回车符、换页符、换行符等
\S	            匹配所有的非空白字符
\w	            匹配所有的单词字符,包括0-9的所有数字、26个英文字母和下画线(_)
\W	            匹配所有的非单词字符
提示：上面的7个预定义字符其实很容易记忆：d 是 digit 的意思,代表数字;s 是 space 的意思,代表空白;w 是 word 的意思,代表单词。
d、s、w 的大写形式恰好匹配与之相反的字符。

有了上面的预定义字符之后,接下来就可以创建更强大的正则表达式了。例如：

re.fullmatch(r'c\wt', 'cat')  # c\wt可以匹配cat、cbt、cct、c0t、c9t等一批字符串
<re.Match object; span=(0, 3), match='cat'>
re.fullmatch(r'c\wt!', 'c9t')  # c\wt可以匹配cat、cbt、cct、c0t、c9t等一批字符串
<re.Match object; span=(0, 3), match='c9t'>
# 匹配如000-000-0000形式的电话号码
re.fullmatch(r'\d\d\d-\d\d\d-\d\d\d\d', '123-456-8888')
<re.Match object; span=(0, 12), match='123-456-8888'>

在一些特殊情况下,例如,若只想匹配 a~f 的字母,或者匹配除 ab 之外的所有小写字母,或者匹配中文字符,
那么上面这些预定义字符就无能为力了,此时就需要使用方括号表达式。方括号表达式有如表10.8所示的几种形式。

表10.8 方括号表达式

方括号表达式	说 明
表示枚举	        例如[abc],表示a、b、c其中任意一个字符：[gz],表示g、z其中任意一个字符
表示范围	        例如[a-f],表示a~f范围内的任意字符;[\\u0041-\\u0056],表示十六进制字符u0041到u0056范围的字符。
范围可以和枚举结合使用,如[a-cx-z],表示a-c、x~z范围内的任意字符
表示求否：^	    例如[^abc],表示非a、b、c的任意字符：[^a-f],表示不是a~f范围内的任意字符

方括号表达式比前面的预定义字符灵活得多,几乎可以匹配任意字符。例如,若需要匹配所有的中文字符,就可以利用[\u0041-\u0056]的形式——
因为所有的中文字符的Unicode值是连续的,只要找出所有中文字符中最小、最大的Unicode值,就可以利用上面的形式来匹配所有的中文字符。

此外,Python正则表达式还支持如表10.9所示的几个边界匹配符。

表10.9 边界匹配符

边界匹配符	说明
^	                行的开头
$	                行的结尾
\b	            单词的边界,即只能匹配单词前后的空白
\B	            非单词的边界,即只能匹配不在单词前后的空白
\A	            只匹配字符串的开头
\Z	            只匹配字符串的结尾,仅用于最后的结束符

10.6.4	子表达式

正则表达式还支持圆括号表达式,用于将多个表达式组成一个子表达式,在圆括号中可以使用或运算符(|)。圆括号表达式也是功能丰富的用法之一。

子表达式(组)支持如下用法。
(exp)：匹配 exp 表达式并捕获成一个自动命名的组,后面可通过"\1"引用第一个捕获组所匹配的子串,
通过"\2"引用第二个捕获组所匹配的子串……依此类推。例如如下代码。

re.search(r'Windows (95|98|NT|2000)[\w ]+\1','windows 98  published  in 98')
<re.Match object; span=(0, 26), match='Windows 98 published in 98'>

在上面代码中用到的正则表达式是r'Windows (95|98|NT|2000)[\w ]+\1', 其中 (95|98|NT|2000) 是一个组,
该组可匹配95、98、 NT 或 2000;接下来是[\w ]+, 这个方括号表达式可匹配任意单词字符和空格,
方括号后面的"+"表示方括号表达式可出现1~N 次;最后是"\1",引用第一个组所匹配的子串——
假如第一个组匹配98,那么"\1"也必须是98,因此该正则表达式可匹配"Windows 98 published in 98"。
将上面代码改为如下形式。

print(re.search(r'Windows (95|98|NT|2000)[\w ]+\1','Windows 98 published in 95'))
None

上面代码中第一个组匹配的子串是98,因此"\1"应该引用子串98,所以该正则表达式无法匹配"Windows 98 published in 95"。

(?P<name>exp)：匹配 exp 表达式并捕获成命名组,该组的名字为 name。后面可通过(?P=name)来引用前面捕获的组。
通过此处介绍不难看出,(exp)和(?P<name>exp)的功能大致相似,只是 exp 捕获的组没有显式指定组名,因此后面使用\1、\2等方式来引用
这种组所匹配的子串;而(?P<name>exp)捕获的组指定了名称,因此后面可通过<?P=name>这种方式来引用 命名组所匹配的子串。

(?P=name)：引用name 命名组所匹配的子串。

例如如下代码。
print(re.search(r'<(?P<tag>\w+)>\w+</(?P=tag)>', '<h3>xx</h3>'))
<re.Match object; span=(0, 11), match='<h3>xx</h3>'>

上面的正则表达式为r<(?P<tag>\w+)>\w+</(?P=tag)>',表达式开始是"<"符号,它直接匹配该符号;
接下来定义了一个命名组：(?P<tag>1w+),该组的组名为 tag,该组能匹配1~N 个任意字符;表达式又定义了一个">"符号,
用于匹配一个 HTML 或 XML  标签。接下来的"\w+"用于匹配标签中的内容;正则表达式又定义了"<",它直接匹配这两个字符;
之后的(?P=tag)就用于引用前面的 tag 组所匹配的子串——也就是说,该正则表达式要求内容必须在合理关闭的 HTML 或 XML 标签内。
因此上面的<h3>xx</h3> 可以匹配。

print(re.search(r'<(?P<tag>\w+)>\w+</(?P=tag)>','<h3>xx</h2>'))
上面的表达式尝试匹配的字符串虽然在 HTML  标签内,但由于前后两个标签不相同,因此不能匹配。

(?:exp):匹配 exp 表达式并且不捕获。这种组与(exp)的区别就在于它是不捕获的,因此不能通过\1、\2等来引用。
例如,在交互式解释器中执行如下命令,将会出现错误,原因是(?:95)98INT |2000)是一个不捕获的组,
因此在该正则表达式中不能使用"\1"来引用该组。
re.search(r'Windows(?:95|98|NT|2000)[a-z]+\1','Windows 98 published in 98')

将上面命令改为如下形式。

print(re.search(r'Windows (?:95|98|NT|2000)[a-z ]+','Windows 98 published in 98'))
<re.Match object; span=(0, 24), match='Windows 98 published in '>

在上面的正则表达式中定义的组是未捕获组,后面也没有使用"\1"来引用该组,因此该正则表达式可以正常匹配。

(?<=exp)：括号中的子模式必须出现在匹配内容的左侧,但 exp 不作为匹配的一部分。
(?=exp)：括号中的子模式必须出现在匹配内容的右侧,但 exp 不作为匹配的一部分。

上面两种组主要用于对匹配内容进行限定,括号中的子模式本身不作为匹配的一部分。例如要获取 HTML 代码中<h1> 元素的内容。
print(re.search(r'(?<=<h1>).+?(?=</h1>)','help! <h1>fkit.org</h1>! technology'))
<re.Match object; span=(10, 18), match='fkit.org'>

在上面的正则表达式中,(?<=<h1>)是一个限定组,该组的内容就是<h1>,由于该组用了(?<=exp) 声明,因此在被匹配内容的左侧必须有<h1>;
还有一个组是(?=</h1>), 该组的内容是</h1>,该组用了(?=exp)声明,因此要求在被匹配内容的右侧必须出现</h1>

所以,上面的正则表达式会将<h1> 和</h1>之间的内容匹配出来。例如：
print(re.search(r'(?<=<h1>).+?(?=</h1>)','help! <h1><div>fkit</div></h1>! technology'))
<re.Match object; span=(10, 25), match='<div>fkit</div>'>

(?<!exp)：括号中的子模式必须不出现在匹配内容的左侧,但 exp 不作为匹配的一部分。其实它是(?<=exp) 的逆向表达。
(?!exp)：括号中的子模式必须不出现在匹配内容的右侧,但 exp 不作为匹配的一部分。其实它是(?=exp)的逆向表达。
(?#comment)：注释组。"?#"后的内容是注释,不影响正则表达式本身。例如：
print(re.search(r'[a-zA-Z0-9_]{3,}(?#username)@fkit\.org', 'sun@fkit.org'))
<re.Match object; span=(0, 12), match='sun@fkit.org'>

在上面代码中,正则表达式内的(?#username)就是注释,用于对正则表达式的部分内容进行说明。

(?aiLmsux)：旗标组,用于为整个正则表达式添加行内旗标,可同时指定一个或多个旗标(关于各旗标的含义可参考10.6.2节的说明)。例如：
print(re.search(r'(?i)[a-z0-9_]{3,}(?#username)@fkit\.org', 'Sun@FKIT.ORG'))
<re.Match object; span=(0, 12), match='Sun@FKIT.ORG'>

在上面的正则表达式中指定了(?i)组,这意味着该正则表达式匹配时不区分大小写,因此该正则表达式可匹配Sun@FKIT.ORG;
如果去掉该旗标组,那么就不能匹配了。

(?imsx-imsx:exp): 只对当前组起作用的旗标。该组旗标与前一组旗标的区别是,前一组旗标作用于整个正则表达式,
而这组旗标只影响组内的子表达式。例如：
print(re.search(r'(?i:[a-z0-9_]){3,}(?#username)@fkit\.org', 'Sun@fkit.org'))
<re.Match object; span=(0, 12), match='Sun@fkit.org'>

在上面的表达式中有一个(?i:[a-z0-9_])组,该组内的子表达式不区分大小写,但整个表达式依然区分大小写。
因此,上面的正则表达式可以匹配Sun@fkit.org,但不能匹配Sun@Fkit.org, 因为后面部分依然区分大小写。

如果在旗标前应用"-",则表明去掉该旗标。比如在执行 search()方法时传入了re.I参数,
这意味着对整个正则表达式不区分大小写;如果希望某个组内的表达式依然区分大小写,则可使用 (-i:exp)来表示。例如：
print(re.search(r'(?-i:[a-z0-9_]){3,}@fkit\.org', 'sun@Fkit.org', re.I))
<re.Match object; span=(0, 12), match='sun@Fkit.org'>

上面例子在执行search()方法时指定了re.I选项,这意味着在执行整个正则表达式匹配时并不区分大小写;
但假如又需要用户名部分区分大小写,于是就把用户名部分放在用组定义成的子表达式中,并为该子表达式指定"?-i:"选项(表明去除 re.I选项),
这样该组内的子表达式就会区分大小写了。因此,上面的表达式可以匹配sun@Fkit.org、sun@fkit.org,但不能匹配Sun@Fkit.org,
因为用户名是区分大小写的。

10.6.5	贪婪模式与勉强模式

在前面例子中需要建立一个匹配000-000-0000形式的电话号码时,使用了r'\d\d\d-\d\d\d-\d\d\d\d' 正则表达式,这看起来比较烦琐。
实际上,正则表达式还提供了频度限定,用于限定前面的模式可出现的次数。Python 正则表达式支持如下几种频度限定。

*：限定前面的子表达式可出现0~N 次。例如正则表达式r'zo*' 能匹配 'z', 也能匹配 'zoo'、'zooo'等。*等价于{0,}。
+：限定前面的子表达式可出现1~N 次。例如正则表达式r'zo+'不能匹配 'z', 可匹配 'zo'. 'zoo'、'zooo'等。+等价于{1,}。
?：限定前面的子表达式出现0~1 次。例如正则表达式r'zo?'能匹配 'z' 和 'zo'两个字符串。?等价于{0,1}。
{n,m}:n 和 m 均为非负整数,其中n≤m,  限定前面的子表达式出现n~m 次。例如正则表达式 r'fo{1,3}d'可匹配
 'fod'、'food'、'foood'这三个字符串。
{n,}:n 是一个非负整数,限定前面的子表达式至少出n次。例如正则表达式 r'fo{2,}d'可匹配 'food'、'foood'、'fooood'等字符串。
{,m}:m 是一个非负整数,限定前面的子表达式至多出现m 次。例如正则表达式 r'fo{,3}d'可匹配 'fd'、'fod'、'food'、'foood'这四个字符串。
{n}:n 是一个非负整数,限定前面的子表达式必须出现 n 次。例如正则表达式 r'fo{2}d'只能匹配 'food'字符串。

在掌握了上面的写法之后,如果再需要书写匹配如000-000-0000形式的电话号码,则可写成

r'\d{3}-\d{3}-\d{4}'。

在默认情况下,正则表达式的频度限定是贪婪模式的。所谓贪婪模式,指的是表达式中的模式会尽可能多地匹配字符。
例如,在交互式解释器中输入如下代码。
print(re.search(r'@.+\.', 'sun@fkit.com.cn'))
<re.Match object; span=(3, 13), match='@fkit.com.'>

上面的正则表达式是 r'@.+\.', 该表达式就是匹配@符号和点号之间的全部内容。但由于在@和点号之间用的是".+",
其中"."可代表任意字符,而且此时是贪婪模式,因此".+"会尽可能多地进行匹配,只要它最后有一个""结尾即可,所以匹配的结果是'@fkit.com.'。

只要在频度限定之后添加一个英文问号,贪婪模式就变成了勉强模式,所谓勉强模式,指的是 表达式中的模式会尽可能少地匹配字符。
例如,在交互式解释器中输入如下代码。
print(re.search(r'@.+?\.', 'sun@fkit.com.cn'))
<re.Match object; span=(3, 9), match='@fkit.'>

上面的正则表达式与前一个示例中的正则表达式基本相似,只是中间部分是",+?",这就是勉强模式。
该模式会尽可能少地匹配字符,只要它最后有一个"."结尾即可,因此匹配的结果是'@fkit.'。

