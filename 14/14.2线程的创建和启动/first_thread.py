"""
前面介绍的绝大部分程序,都只是在做单线程的编程。
前面所有程序(除第11章中的程序之外,它们有内建的多线程支持)都只有一条顺序执行流——
程序依次向下执行每行代码,如果程序在执行某行代码时遇到阻塞,则程序将会停滞在该处。
使用IDE工具的单步调试功能,就可以非常清楚地看出这一点。

但实际的情况是,单线程的程序往往功能非常有限。
例如,开发一个简单的服务器程序,当这个服务器程序需要向不同的客户端提供服务时,不同的客户端之间应该互不干扰。
多线程听上去是非常专业的概念,其实它非常简单——
单线程的程序(前面介绍的绝大部分程序)只有一个顺序执行流,而多线程的程序则可以包含多个顺序执行流,这些顺序执行流之间互不干扰。
可以这样理解： 单线程的程序如同只雇佣一个服务员的餐厅,他必须做完一件事情后才可以做下一件事情;
而多线程的程序则如同雇佣多个服务员的餐厅,他们可以同时做多件事情。

Python 语言提供了非常优秀的多线程支持,程序可以通过非常简单的方式来启动多线程。
本章将会详细介绍Python多线程编程的相关知识,包括创建、启动线程,控制线程,以及多线程的同步操作,
并会介绍如何利用Python内建支持的线程池来提高多线程的性能。

14.1	线程概述

几乎所有的操作系统都支持同时运行多个任务,一个任务通常就是一个程序,每一个运行中的程序就是一个进程。
当一个程序运行时,内部可能包含多个顺序执行流,每一个顺序执行流就是一个线程。

14.1.1	线程和进程

几乎所有的操作系统都支持进程的概念,所有运行中的任务通常对应一个进程(Process)。当一个程序进入内存运行时,即变成一个进程。
进程是处于运行过程中的程序,并且具有一定的独立功能。进程是系统进行资源分配和调度的一个独立单位。

一般而言,进程包含如下三个特征。
(1)独立性：进程是系统中独立存在的实体,它可以拥有自己的独立的资源,每一个进程都拥有自己的私有的地址空间。
在没有经过进程本身允许的情况下,一个用户进程不可以直接访问其他进程的地址空间。
(2)动态性：进程与程序的区别在于,程序只是一个静态的指令集合,而进程是一个正在系统中活动的指令集合。
在进程中加入了时间的概念。进程具有自己的生命周期和各种不同的状态,在程序中是没有这些概念的。
(3)并发性：多个进程可以在单个处理器上并发执行,多个进程之间不会互相影响。

注意：并发(Concurrency)和并行(Parallel)是两个概念,并行指在同一时刻有多条指令在多个处理器上同时执行;
并发指在同一时刻只能有一条指令执行,但多个进程指令被快速轮换执行,使得在宏观上具有多个进程同时执行的效果。

大部分操作系统都支持多进程并发执行,现代的操作系统几乎都支持同时执行多个任务。
例如, 程序员一边开着开发工具在写程序,一边开着参考手册备查,同时还使用电脑播放音乐……
除此之外,每台电脑运行时还有大量底层的支撑性程序在运行……这些进程看上去像是在同时工作。

但事实的真相是,对于一个 CPU 而言,在某个时间点它只能执行一个程序。
也就是说,只能运行一个进程, CPU 不断地在这些进程之间轮换执行。那么,为什么用户感觉不到任何中断呢?

这是因为相对人的感觉来说, CPU 的执行速度太快了(如果启动的程序足够多,则用户依然可以感觉到程序的运行速度下降了)。
所以,虽然 CPU 在多个进程之间轮换执行,但用户感觉到好像有多个进程在同时执行。

现代的操作系统都支持多进程的并发执行,但在具体的实现细节上可能因为硬件和操作系统的不同而采用不同的策略。
比较常用的策略有：共用式的多任务操作策略,例如 Windows 3.1和Mac OS 9操作系统采用这种策略;
抢占式的多任务操作策略,其效率更高,目前操作系统大多采用这 种策略,例如Windows NT、Windows 2000以及UNIX/Linux 等操作系统。

多线程则扩展了多进程的概念,使得同一个进程可以同时并发处理多个任务。
线程(Thread)也被称作轻量级进程(Lightweight Process), 线程是进程的执行单元。
就像进程在操作系统中的地位一样,线程在程序中是独立的、并发的执行流。当进程被初始化后,主线程就被创建了。
对于绝大多数的应用程序来说,通常仅要求有一个主线程,但也可以在进程内创建多个顺序执行流,这些顺序执行流就是线程,每一个线程都是独立的。

线程是进程的组成部分, 一个进程可以拥有多个线程, 一个线程必须有一个父进程。
线程可以拥有自己的堆栈、自己的程序计数器和自己的局部变量,但不拥有系统资源,它与父进程的其他线程共享该进程所拥有的全部资源。
因为多个线程共享父进程里的全部资源,因此编程更加方便;但必须更加小心,因为需要确保线程不会妨碍同一进程中的其他线程。

线程可以完成一定的任务,可以与其他线程共享父进程中的共享变量及部分环境,相互之间协同来完成进程所要完成的任务。

线程是独立运行的,它并不知道进程中是否还有其他线程存在。
线程的运行是抢占式的,也就是说,当前运行的线程在任何时候都可能被挂起,以便另外一个线程可以运行。

一个线程可以创建和撤销另一个线程,同一个进程中的多个线程之间可以并发运行。

从逻辑的角度来看,多线程存在于一个应用程序中,让一个应用程序可以有多个执行部分同时执行,
但操作系统无须将多个线程看作多个独立的应用,对多线程实现调度和管理,以及资源分配。 线程的调度和管理由进程本身负责完成。

简而言之, 一个程序运行后至少有一个进程,在一个进程中可以包含多个线程,但至少要包含一个主线程。

提示：归纳起来,可以这样说：操作系统可以同时执行多个任务,每一个任务就是一个进 程；进程可以同时执行多个任务,每一个任务就是一个线程。

14.1.2	多线程的优势

线程在程序中是独立的、并发的执行流。与分隔的进程相比,进程中线程之间的隔离程度要小,它们共享内存、文件句柄和其他进程应有的状态。

因为线程的划分尺度小于进程,使得多线程程序的并发性高。
进程在执行过程中拥有独立的内存单元,而多个线程共享内存,从而极大地提高了程序的运行效率。

线程比进程具有更高的性能,这是由于同一个进程中的线程都有共性——多个线程共享同一个进程的虚拟空间。
线程共享的环境包括进程代码段、进程的公有数据等,利用这些共享的数据,线程之间很容易实现通信。

操作系统在创建进程时,必须为该进程分配独立的内存空间,并分配大量的相关资源,但创建线程则简单得多。
因此,使用多线程来实现并发比使用多进程的性能要高得多。

总结起来,使用多线程编程具有如下几个优点。
(1)进程之间不能共享内存,但线程之间共享内存非常容易。
(2)操作系统在创建进程时,需要为该进程重新分配系统资源,但创建线程的代价则小得多。
因此,使用多线程来实现多任务并发执行比使用多进程的效率高。
(3)Python 语言内置了多线程功能支持,而不是单纯地作为底层操作系统的调度方式,从而简化了Python的多线程编程。

在实际应用中,多线程是非常有用的。比如一个浏览器必须能同时下载多张图片;
一个 Web  服务器必须能同时响应多个用户请求;图形用户界面(GUI)应用也需要启动单独的线程,从主机环境中收集用户界面事件……
总之,多线程在实际编程中的应用是非常广泛的。

14.2	线程的创建和启动

Python提供了 _thread 和 threading 两个模块来支持多线程,其中 _thread 提供低级别的、原始的线程支持,以及一个简单的锁,
正如它的名字所暗示的, 一般编程不建议使用 _thread 模块；而 threading 模块则提供了功能丰富的多线程支持。

Python主要通过两种方式来创建线程。
(1)使用 threading 模块的 Thread 类的构造器创建线程。
(2)继承 threading 模块的 Thread 类创建线程类。

14.2.1	调用Thread类的构造器创建线程

调用Thread类的构造器创建线程很简单,直接调用threading.Thread类的如下构造器创建线程。
    def __init__(self, group=None, target=None, name=None,
                 args=(), kwargs=None, *, daemon=None):

上面的构造器涉及如下几个参数。
(1)group:指定该线程所属的线程组。目前该参数还未实现,因此它只能设为None。
(2)target:指定该线程要调度的目标方法。
(3)args:指定一个元组,以位置参数的形式为target指定的函数传入参数。
元组的第一个元素传给target 函数的第一个参数,元组的第二个元素传给target函数的第二个参数……依此类推。
(4)kwargs:指定一个字典,以关键字参数的形式为target指定的函数传入参数。
(5)daemon:指定所构建的线程是否为后代线程。

通过Thread类的构造器创建并启动多线程的步骤如下。
① 调用Thread 类的构造器创建线程对象。在创建线程对象时, target 参数指定的函数将作为线程执行体。
② 调用线程对象的 start() 方法启动该线程。

下面程序示范了通过Thread类的构造器来创建线程对象。
"""
import threading


# 定义一个普通的action函数,该函数准备作为线程执行体
def action(max):
    for i in range(max):
        # 调用threading模块current_thread()函数获取当前线程
        # 线程对象的getName()方法获取当前线程的名字
        print(threading.current_thread().getName() + " " + str(i))


# 下面是主程序（也就是主线程的执行体）
for i in range(100):
    # 调用threading模块current_thread()函数获取当前线程
    print(threading.current_thread().getName() + " " + str(i))
    if i == 20:
        # 创建并启动第一个线程
        t1 = threading.Thread(target=action, args=(100,))
        t1.start()
        # 创建并启动第二个线程
        t2 = threading.Thread(target=action, args=(100,))
        t2.start()
print('主线程执行完成!')
"""
上面程序中的主程序包含一个循环,当循环变量 i 等于20时创建并启动两个新线程。
程序中第一行粗体字代码创建了一个 Thread 对象,该线程的target为 action,这意味着它会将 action 函数作为线程执行体。
接下来程序调用start()方法来启动 t1 线程。

程序中第二行粗体字代码再次创建了一个线程,其创建和启动方式与第一个线程完全相同。

运行上面程序,将会看到如图14.1所示的界面。

虽然上面程序只显式创建并启动了两个线程,但实际上程序有三个线程,即程序显式创建的两个子线程和主线程。
前面已经提到, 当 Python 程序开始运行后,程序至少会创建一个主线程,主线程的线程执行体就是程序中的主程序——没有放在任何函数中的代码。

提示：在进行多线程编程时,不要忘记 Python 程序运行时默认的主线程,主程序部分(没有放在任何函数中的代码)就是主线程的线程执行体。

从图14.1可以看出,此时程序中共包含三个线程,这三个线程的执行没有先后顺序,它们以并发方式执行：
Thread-1执行一段时间,然后可能Thread-2或 MainThread 获得CPU 执行一段时间,接下来又换其他线程执行,
这就是典型的线程并发执行——CPU 以快速轮换的方式在多个线程之间切换,从而给用户一种错觉：多个线程似乎同时在执行。

通过上面介绍不难看出多线程的意义：如果不使用多线程,主程序直接调用两次action()函数,
那么程序必须等第一次调用的action()函数执行完成,才会执行第二次调用的action()函数;
必须等第二次调用的action()函数执行完成,才会继续向下执行主程序。
而使用多线程之后,程序可以让两个 action() 函数、主程序以并发方式执行,给用户一种错觉：两个action()函数和主程序似乎同时在执行。

提示：说穿了很简单,多线程就是让多个函数能并发执行,让普通用户感觉到多个函数似乎同时在执行。

除此之外,上面程序还用到了如下函数和方法。
(1)threading.current_thread(): 它 是threading模块的函数,该函数总是返回当前正在执行的线程对象。
(2)getName(): 它是 Thread 类的实例方法,该方法返回调用它的线程名字。

提示：程序可以通过 setName(name)方法为线程设置名字,也可以通过 getName()方法返回指定线程的名字,
这两个方法可通过name 属性来代替。
在默认情况下,主线程的名字为 MainThread,用户启动的多个线程的名字依次为 Thread-1、Thread-2、Thread-3.… 、 Thread-n等。
"""