"""
当线程被创建并启动以后,它既不是一启动就进入执行状态的,也不是一直处于执行状态的,在线程的生命周期中,
它要经过新建(New)、就绪(Ready)、运行(Running)、阻塞(Blocked)和死亡(Dead)5种状态。
尤其是当线程启动以后,它不可能一直"霸占"着 CPU 独自运行,所以 CPU 需要在多个线程之间切换,于是线程状态也会多次在运行、就绪之间转换。

14.3.1	新建和就绪状态

当程序创建了一个 Thread 对象或 Thread 子类的对象之后,该线程就处于新建状态,和其他的 Python 对象一样,
此时的线程对象并没有表现出任何线程的动态特征,程序也不会执行线程执行体。

当线程对象调用start)方法之后,该线程处于就绪状态, Python 解释器会为其创建方法调用栈和程序计数器,
处于这种状态中的线程并没有开始运行,只是表示该线程可以运行了。至于该线程何时开始运行,取决于Python 解释器中线程调度器的调度。

注意：启动线程使用 start()方法,而不是run()方法!永远不要调用线程对象的 run()方法 !
调用start()方法来启动线程,系统会把该run()方法当成线程执行体来处理;
但如果直接调用线程对象的run()方法,则run()方法立即就会被执行,而且在该方法返回之前其他线程无法并发执行——
也就是说,如果直接调用线程对象的run()方法,则系统把线程对象当成一个普通对象,而 run()方法也是一个普通方法,而不是线程执行体。
"""
import threading


# 定义准备作为线程执行体的action函数
def action(max):
    for i in range(max):
        # 直接调用run()方法时,Thread的name属性返回的是该对象的名字
        # 而不是当前线程的名字
        # 使用threading.current_thread().name总是获取当前线程的名字
        print(threading.current_thread().name + " " + str(i))  # ①


for i in range(100):
    # 调用Thread的currentThread()方法获取当前线程
    print(threading.current_thread().name + " " + str(i))
    if i == 20:
        # 直接调用线程对象的run()方法
        # 系统会把线程对象当成普通对象,把run()方法当成普通方法
        # 所以下面两行代码并不会启动两个线程,而是依次执行两个run()方法
        threading.Thread(target=action, args=(100,)).run()
        threading.Thread(target=action, args=(100,)).run()
"""
上面程序在创建线程对象后,直接调用了线程对象的run()方法(如粗体字代码所示),程序运行的结果是整个程序只有一个线程：主线程。
还有一点需要指出,如果直接调用线程对象的 run()方法,则在run()方法中不能直接通过 name 属性(getName()方法)
来获取当前执行线程的名字,而是需要使用threading.current_thread()函数先获取当前线程,
然后再调用线程对象的 name 属性来获取线程的名字。

通过上面程序不难看出,启动线程的正确方法是调用 Thread 对象的 start()方法,而不是直接调用 run()方法;否则就变成单线程程序了。

需要指出的是,在调用线程对象的 run()方法之后,该线程已经不再处于新建状态,不要再次调用线程对象的 start()方法。

注意：只能对处于新建状态的线程调用 start()方法。也就是说,如果程序对同一个线程重复调用 start()方法,将引发 RuntimeError异常。

在调用线程对象的 start()方法之后,该线程立即进入就绪状态---相当于"等待执行",但该线程并未真正进入运行状态。
"""