"""
1.  根据Python 的参数传递机制,我们知道：传入函数的只是参数的副本,因此程序在函数中对 参数赋值并不会影响参数本身。
如果参数本身是一个可变对象(比如列表、字典等),此时虽然Python采用的也是值传递方式,
但许多初学者可能会对这种类型的参数传递产生一些误会。下面程序示范了这种类型的参数传递的效果。
2.  从上面的运行结果来看,在swap()函数里,dw 字典的a、b 两个元素的值被交换成功。
不仅如 此,当swap()函数执行结束后,主程序中dw 字典的 a、b 两个元素的值也被交换了。
这很容易造 成一种错觉：在调用swap (函数时,传入swap()函数的就是dw 字典本身,而不是它的复制品。
但 这只是一种错觉,下面还是结合示意图来说明程序的执行过程。
3.  程序开始创建了一个字典对象,并定义了一个dw 引用变量指向字典对象,这意味着此时内存 中有两个东西：
对象本身和指向该对象的引用变量。此时在系统内存中的存储示意图如图5.5所示。
4.  接下来主程序开始调用swap()函数,在调用swap()函数时,dw 变量作为参数传入swap()函数,
同样采用值传递方式：把主程序中dw 变量的值赋给swap()函数的dw 形参,从而完成swap()函数 的 dw 参数的初始化。
值得指出的是,主程序中的dw 是一个引用变量(也就是一个指针),它保存 了字典对象的地址值,
当把dw 的值赋给swap (函数的dw 参数后,就是让swap()函数的dw 参数 也保存这个地址值,即也会引用到同一个字典对象。
图5.6显示了dw 字典传入swap()函数后的存 储示意图。
5.  从图5.6来看,这种参数传递方式是不折不扣的值传递方式,系统一样复制了dw 的副本传入swap()函数。
但由于dw 只是一个引用变量,因此系统复制的是dw 变量,并未复制字典本身。
6.  当程序在swap()函数中操作dw 参数时,由于dw 只是一个引用变量,故实际操作的还是字典 对象。
此时,不管是操作主程序中的dw 变量,还是操作swap()函数里的dw 参数,其实操作的都 是它们共同引用的字典对象,
它们引用的是同一个字典对象。因此,当在swap()函数中交换dw 参 数所引用字典对象的a、b两个元素的值后,
可以看到在主程序中dw 变量所引用字典对象的a、b 两个元素的值也被交换了。
7.  为了更好地证明主程序中的dw 和swap()函数中的dw 是两个变量,在swap()函数的最后一行 增加如下代码：
把 dw 直接赋值为None, 让它不再指向任何对象
dw      =      None
8.  运行上面代码,结果是swap()函数中的dw变量不再指向任何对象,程序其他地方没有任何改变。
主程序调用swap()函数后,再次访问dw变量的a、b两个元素,依然可以输出9、6。可见, 主程序中的dw变量没有受到任何影响。
实际上,当在swap()函数中增加"dw = None"代码后, 在内存中的存储示意图如图5.7所示。
9.  从图5.7来看,把swap()函数中的dw赋值为None后,在swap()函数中失去了对字典对象的引用,不可再访问该字典对象。
但主程序中的dw变量不受任何影响,依然可以引用该字典对象, 所以依然可以输出字典对象的a、b元素的值。
通过上面介绍可以得出如下两个结论。
(1)不管什么类型的参数,在Python函数中对参数直接使用"="符号赋值是没用的,直接使用"="符号赋值并不能改变参数。
(2)如果需要让函数修改某些数据,则可以通过把这些数据包装成列表、字典等可变对象,然后把列表、字典等可变对象作为参数传入函数,
在函数中通过列表、字典的方法修改它们, 这样才能改变这些数据。
"""


def swap(dw):
    # 下面代码实现dw的a、b两个元素的值交换
    dw['a'], dw['b'] = dw['b'], dw['a']
    print("swap函数里,a元素的值是", dw['a'], "；b元素的值是", dw['b'])
    # 把dw直接赋值为None,让它不再指向任何对象
    dw = None


dw = {'a': 6, 'b': 9}
swap(dw)
print("交换结束后,a元素的值是", dw['a'], "；b元素的值是", dw['b'])
