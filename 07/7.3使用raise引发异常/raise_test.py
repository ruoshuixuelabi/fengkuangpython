"""
7.3 使用raise引发异常

1.  当程序出现错误时,系统会自动引发异常。除此之外, Python 也允许程序自行引发异常,自行引发异常使用raise语句来完成。

7.3.1 引发异常

2.  异常是一种很"主观"的说法,以下雨为例,假设大家约好明天去爬山郊游,如果第二天下雨了,
这种情况会打破既定计划,就属于一种异常；但对于正在期盼天降甘霖的农民而言,如果第二 天下雨了,他们正好随雨追肥,这就完全正常。
3.  很多时候,系统是否要引发异常,可能需要根据应用的业务需求来决定,如果程序中的数据、 执行与既定的业务需求不符,这就是一种异常。
由于与业务需求不符而产生的异常,必须由程序员来决定引发,系统无法引发这种异常。
4.  如果需要在程序中自行引发异常,则应使用raise语句。 raise语句有如下三种常用的用法。
(1)raise：单独一个raise。 该语句引发当前上下文中捕获的异常(比如在except块中),或默认引发RuntimeError异常。
(2)raise异常类：raise后带一个异常类。该语句引发指定异常类的默认实例。
(3)raise异常对象：引发指定的异常对象。
5.  上面三种用法最终都是要引发一个异常实例(即使指定的是异常类,实际上也是引发该类的默认实例), raise语句每次只能引发一个异常实例。
6.  即使是用户自行引发的异常,也可以使用try…except来捕获它。当然也可以不管它,让该异常 向上(先调用者)传播,
如果该异常传到 Python 解释器,那么程序就会中止。下面示例示范了处 理用户引发异常的两种方式。
7.  从上面程序可以看到,程序既可在调用mtd(3)时使用try…except来捕获异常,这样该异常将会被 except 块捕获,
不会传播给调用它的函数；也可直接调用mtd(3), 这样该函数的异常就会直接 传播给它的调用函数,如果该函数也不处理该异常,
就会导致程序中止。
8.  上面第一行输出是第一次调用 mtd(3)的结果,该方法引发的异常被 except 块捕获并处理。
后面的大段输出则是第二次调用 mtd(3)的结果,由于该异常没有被except 块捕获,因此该异常一直 向上传播,
直到传给Python 解释器导致程序中止。
9.  第二次调用mtd(3)引发的以"File"开头的三行输出,其实显示的就是异常的传播轨迹信息。
也就是说,如果程序不对异常进行处理, Python 默认会在控制台输出异常 的传播轨迹信息。
"""
import traceback


def main():
    try:
        # 使用try...except来捕捉异常
        # 此时即使程序出现异常,也不会传播给main函数
        mtd(3)
    except Exception as e:
        print('程序出现异常:', e)
        #        help(e.with_traceback)
        traceback.print_exc()
    #        e.with_traceback(e)
    # 不使用try...except捕捉异常,异常会传播出来导致程序中止
    mtd(3)


def mtd(a):
    if a > 0:
        raise ValueError("a的值大于0,不符合要求")


main()
