"""
实际上,Python 完全允许使用对象来访问该对象所属类的类变量(当然还是推荐使用类访问类变量)。例如如下程序。
"""


class Record:
    # 定义两个类变量
    item = '鼠标'
    date = '2016-06-16'

    def info(self):
        print('info方法中: ', self.item)
        print('info方法中: ', self.date)


rc = Record()
print(rc.item)  # '鼠标'
print(rc.date)  # '2016-06-16'
rc.info()
# 由于通过对象访问类变量的本质还是通过类名在访问,因此如果类变量发生了改变,当程序访问这些类变量时也会读到修改之后的值。
# 修改Record类的两个类变量
Record.item = '键盘'
Record.date = '2016-08-18'
# 调用info()方法
rc.info()
"""
上面程序的 Record 中定义了两个类变量,接下来程序完全可以使用 Record 对象来访问这两个类变量。

在上面程序的 Record 类的 info() 方法中,程序使用 self 访问 Record 类的类变量,此时 self代表 info()方法的调用者,
也就是Record 对象,因此这是合法的。

在主程序代码区,程序创建了Record 对象,并通过对象调用Record 对象的item、date类变量,这也是合法的。

实际上,程序通过对象访问类变量,其本质还是通过类名在访问类变量。运行上面程序,将看到如下输出结果。
鼠标
2016-06-16
info方法中:  鼠标
info方法中:  2016-06-16

由于通过对象访问类变量的本质还是通过类名在访问,因此如果类变量发生了改变,当程序访问这些类变量时也会读到修改之后的值。
Record.item = '键盘'
Record.date = '2016-08-18'
# 调用info()方法
rc.info()

上面程序修改了 Record 类的两个类变量,然后通过对象调用 info 实例方法。运行上面代码,将看到如下输出结果。
info方法中:  键盘
info方法中:  2016-08-18

从上面的输出结果可以看到,通过实例访问类变量的本质依然是通过类名在访问。
需要说明的是,Python 允许通过对象访问类变量,但如果程序通过对象尝试对类变量赋值,此时性质就变了——
Python 是动态语言,赋值语句往往意味着定义新变量。
"""