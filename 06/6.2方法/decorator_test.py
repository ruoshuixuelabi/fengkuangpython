"""
6.2.3 @函数装饰器
1.  前面介绍的@staticmethod和 @classmethod 的本质就是函数装饰器,其中 staticmethod 和 classmethod都是Python内置的函数。
2.  使用@符号引用已有的函数(比如@staticmethod、@classmethod)后,可用于修饰其他函数, 装饰被修饰的函数。
那么我们是否可以开发自定义的函数装饰器呢?答案是肯定的。
3.  当程序使用"@函数"(比如函数A)装饰另一个函数(比如函数B)时,实际上完成如下两步
①将被修饰的函数(函数B)作为参数传给@符号引用的函数(函数A)。
②将函数B替换(装饰)成第①步的返回值。
从上面介绍不难看出,被"@函数"修饰的函数不再是原来的函数,而是被替换成一个新的东西。
4.  为了让大家厘清函数装饰器的作用,下面看一个非常简单的示例。
5.  通过这个例子,相信读者对函数装饰器的执行关系已经有了一个较为清晰的认识,但读者可能会产生另一个疑问：
这个函数装饰器导致被修饰的函数变成了字符串,那么函数装饰器有什么用?  
别忘记了,被修饰的函数总是被替换成@符号所引用的函数的返回值,因此被修饰的函数会变成什么,
完全由于@符号所引用的函数的返回值决定——如果@符号所引用的函数的返回值是函数,那么被修饰的函数在替换之后还是函数。
6.  通过@符号来修饰函数是Python的一个非常实用的功能,它既可以在被修饰函数的前面添加一些额外的处理逻辑(比如权限检查),
也可以在被修饰函数的后面添加一些额外的处理逻辑(比如记录日志),还可以在目标方法抛出异常时进行一些修复操作
……这种改变不需要修改被修饰函数的代码,只要增加一个修饰即可。
7.  上面介绍的这种在被修饰函数之前、之后、抛出异常后增加某种处理逻辑的方式,
就是其他编程语言中的AOP(Aspect Orient Programming,面向切面编程)。
"""


def funA(fn):
    print('A')
    fn()  # 执行传入的fn参数
    return 'fkit'


'''
下面装饰效果相当于：funA(funB),
funB将会替换（装饰）成该语句的返回值；
由于funA()函数返回fkit,因此funB就是fkit
'''


@funA
def funB():
    print('B')


print(funB)  # fkit


def foo(fn):
    # 定义一个嵌套函数
    def bar(*args):
        print("===1===", args)
        n = args[0]
        print("===2===", n * (n - 1))
        # 查看传给foo函数的fn函数
        print(fn.__name__)
        fn(n * (n - 1))
        print("*" * 15)
        return fn(n * (n - 1))

    return bar


'''
下面装饰效果相当于：foo(my_test),
my_test将会替换（装饰）成该语句的返回值；
由于foo()函数返回bar函数,因此funB就是bar
'''


# 下面程序使用@foo修饰 my_test() 函数,因此程序同样会执行foo(my_test), 并将 my_test 替换成foo()函数的返回值：bar函数。
# 所以,下面程序第二行粗体字代码在打印 my_test 函数时,实际上输出的是bar函数,这说明my test已经被替换成bar函数。
# 接下来程序两次调用 my_test()函数, 实际上就是调用bar()函数。
@foo
def my_test(a):
    print("==my_test函数==", a)


# 打印my_test函数,将看到实际上是bar函数
print(my_test)  # <function foo.<locals>.bar at 0x00000000021FABF8>
# 下面代码看上去是调用my_test(),其实是调用bar()函数
my_test(10)
my_test(6, 5)
