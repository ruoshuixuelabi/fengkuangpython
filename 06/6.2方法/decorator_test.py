"""
6.2.3 @函数装饰器

前面介绍的 @staticmethod 和 @classmethod 的本质就是函数装饰器,其中 staticmethod 和 classmethod 都是 Python 内置的函数。

使用@符号引用已有的函数(比如@staticmethod、@classmethod)后,可用于修饰其他函数,装饰被修饰的函数。
那么我们是否可以开发自定义的函数装饰器呢?答案是肯定的。

当程序使用"@函数"(比如函数A)装饰另一个函数(比如函数B)时,实际上完成如下两步
①将被修饰的函数(函数B)作为参数传给@符号引用的函数(函数A)。
②将函数B替换(装饰)成第①步的返回值。
从上面介绍不难看出,被"@函数"修饰的函数不再是原来的函数,而是被替换成一个新的东西。

为了让大家厘清函数装饰器的作用,下面看一个非常简单的示例。
"""


def funA(fn):
    print('A')
    fn()  # 执行传入的fn参数
    return 'fkit'


'''
下面装饰效果相当于：funA(funB),
funB 将会替换(装饰)成该语句的返回值;由于 funA() 函数返回 fkit,因此 funB 就是fkit
'''


@funA
def funB():
    print('B')


print(funB)  # fkit
"""
上面程序使用 @funA 修饰 funB,这意味着程序要完成两步操作。
①将 funB 作为 funA()的参数,也就是上面的粗体字代码相当于执行 funA(funB)。
②将 funB 替换成第①步执行的结果,funA()执行完成后返回 fkit,因此 funB 就不再是函数,而是被替换成一个字符串。
运行上面程序,可以看到如下输出结果。
A
B
fkit

通过这个例子,相信读者对函数装饰器的执行关系已经有了一个较为清晰的认识,但读者可能会产生另一个疑问：
这个函数装饰器导致被修饰的函数变成了字符串,那么函数装饰器有什么用?  
别忘记了,被修饰的函数总是被替换成@符号所引用的函数的返回值,因此被修饰的函数会变成什么,
完全由于@符号所引用的函数的返回值决定——如果@符号所引用的函数的返回值是函数,那么被修饰的函数在替换之后还是函数。

下面程序示范了更复杂的函数装饰器(程序清单同上)
"""


def foo(fn):
    # 定义一个嵌套函数
    def bar(*args):
        print("===1===", args)
        n = args[0]
        print("===2===", n * (n - 1))
        # 查看传给foo函数的fn函数
        print(fn.__name__)
        fn(n * (n - 1))
        print("*" * 15)
        return fn(n * (n - 1))

    return bar


'''
下面装饰效果相当于：foo(my_test),
my_test将会替换(装饰)成该语句的返回值;由于foo()函数返回bar函数,因此funB就是bar
'''


# 下面程序使用 @foo 修饰 my_test()函数,因此程序同样会执行 foo(my_test),并将 my_test 替换成foo()函数的返回值：bar函数。
# 所以,下面程序第二行粗体字代码在打印 my_test 函数时,实际上输出的是 bar 函数,这说明my test已经被替换成bar函数。
# 接下来程序两次调用 my_test()函数,实际上就是调用 bar() 函数。
@foo
def my_test(a):
    print("==my_test函数==", a)


# 打印 my_test 函数,将看到实际上是 bar 函数
print(my_test)  # <function foo.<locals>.bar at 0x00000000021FABF8>
# 下面代码看上去是调用my_test(),其实是调用bar()函数
my_test(10)
my_test(6, 5)
"""
上面程序定义了一个装饰器函数 foo,该函数执行完成后并不是返回普通值,而是返回 bar 函数(这是关键),
这意味着被该@foo修饰的函数最终都会被替换成bar函数。

上面程序使用@foo修饰 my_test()函数,因此程序同样会执行foo(my_test),并将 my_test 替换成 foo()函数的返回值：bar 函数。
所以,上面程序第二行粗体字代码在打印 my_test 函数时,实际上输出的是bar函数,这说明 my_test 已经被替换成bar函数。
接下来程序两次调用 my_test()函数,实际上就是调用bar()函数。
运行上面程序,可以看到如下输出结果。

<function foo.<locals>.bar at 0x000001E592A99990>
===1=== (10,)
===2=== 90
my_test
==my_test函数== 90
***************
==my_test函数== 90
===1=== (6, 5)
===2=== 30
my_test
==my_test函数== 30
***************
==my_test函数== 30

通过@符号来修饰函数是 Python 的一个非常实用的功能,它既可以在被修饰函数的前面添加一些额外的处理逻辑(比如权限检查),
也可以在被修饰函数的后面添加一些额外的处理逻辑(比如记录日志),
还可以在目标方法抛出异常时进行一些修复操作……这种改变不需要修改被修饰函数的代码,只要增加一个修饰即可。

上面介绍的这种在被修饰函数之前、之后、抛出异常后增加某种处理逻辑的方式,
就是其他编程语言中的AOP(Aspect Orient Programming,面向切面编程)。
"""
