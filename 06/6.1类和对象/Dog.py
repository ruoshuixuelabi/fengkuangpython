"""
6.1.4 实例方法和自动绑定 self

对于在类体中定义的实例方法,Python 会自动绑定方法的第一个参数(通常建议将该参数命名为self),
第一个参数总是指向调用该方法的对象。根据第一个参数出现位置的不同,第一个参数所绑定的对象略有区别。
(1)在构造方法中引用该构造方法正在初始化的对象。
(2)在普通实例方法中引用调用该方法的对象。

由于实例方法(包括构造方法)的第一个 self 参数会自动绑定,因此程序在调用普通实例方法、构造方法时不需要为第一个参数传值。

self 参数(自动绑定的第一个参数)最大的作用就是引用当前方法的调用者,比如前面介绍的在构造方法中通过 self 为该对象增加实例变量。
也可以在一个实例方法中访问该类的另一个实例方法或变量。假设定义了一个 Dog 类,
这个 Dog 对象的 run() 方法需要调用它的 jump() 方法,此时就可通过self参数作为 jump() 方法的调用者。

方法的第一个参数所代表的对象是不确定的,但它的类型是确定的——它所代表的只能是当前类的实例;
只有当这个方法被调用时,它所代表的对象才被确定下来——谁在调用这个方法,方法的第一个参数就代表谁。

例如定义如下Dog 类。
"""


class Dog:
    # 定义一个jump()方法
    def jump(self):
        print("正在执行jump方法")

    # 定义一个run()方法,run()方法需要借助jump()方法
    def run(self):
        # 使用self参数引用调用run()方法的对象
        self.jump()
        print("正在执行run方法")


d = Dog()
d.run()
"""
上面代码的 run() 方法中的 self 代表该方法的调用者：谁在调用 run() 方法,那么 self 就代表谁。
因此该方法表示：当一个 Dog 对象调用 run() 方法时,run() 方法需要依赖它自己的 jump() 方法。

在现实世界里,对象的一个方法依赖另一个方法的情形很常见,
例如,吃饭方法依赖拿筷子方法,写程序方法依赖敲键盘方法,这种依赖都是同一个对象的两个方法之间的依赖。

当Python对象的一个方法调用另一个方法时,不可以省略self。也就是说,将上面的 run() 方法改为如下形式是不正确的。
    def jump(self):
        print("正在执行jump方法")

    # 定义一个run()方法,run()方法需要借助jump()方法
    def run(self):
        # 省略self,下面代码会报错
        jump()
        print("正在执行run方法")
        
从Python语言的设计来看,Python的类、对象有点类似于一个命名空间,因此在：
调用类、对象的方法时,一定要加上"类."或"对象."的形式。如果直接调用某个方法,这种形式属于调用函数。
"""