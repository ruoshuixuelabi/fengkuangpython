"""
8.4.2	生成器的方法
1.  当生成器运行起来之后,开发者还可以为生成器提供值,通过这种方式让生成器与"外部程序" 动态地交换数据。
2.  为了实现生成器与"外部程序"动态地交换数据,需要借助于生成器的send()方法,该方法的功能与前面示例中所使用的next()
函数的功能非常相似,它们都用于获取生成器所生成的下一个值, 并将生成器"冻结"在 yield 语句处;
但send()方法可以接收一个参数,该参数值会被发送给生成器函数。
3.  在生成器函数内部,程序可通过yield表达式来获取send()方法所发送的值——这意味着此时程序应该使用一个变量来接收 yield语句的值。
如果程序依然使用 next()函数来获取生成器所生成 的下一个值,那么yield语句返回None。
4.  对于上面详细的描述,归纳起来就是两句话。
(1)外部程序通过send()方法发送数据。
(2)生成器函数使用yield语句接收收据。
5.  另外,需要说明的是,只有等到生成器被"冻结"之后,外部程序才能使用send()方法向生成器发送数据。
获取生成器第一次所生成的值,应该使用next()函数;如果程序非要使用send()方法获取生成器第一次所生成的值,
也不能向生成器发送数据,只能为该方法传入None 参数。
6.  下面程序示范了向生成器发送数据。该程序会依次生成每个整数的平方值,但外部程序可以向生成器发送数据,
当生成器接收到外部数据之后会生成外部数据的平方值。
7.  该程序与前面的简单生成器程序的区别就在于粗体字代码行,这行代码在yield语句(yield语句被放在if表达式中,
整个表达式只会返回一个yield语句)的左边放了一个变量,该变量就用于 接收生成器send()方法所发送的值。
8.  上面程序第一次使用生成器的send()方法来获取生成器的下一个值,因此只能为send()方法传入None 作为参数。
程序执行到粗体字代码处,由于此时 out_val 为 None, 因此程序执行yield i ** 2(生成器返回0),程序被"冻结" — —
注意,当程序被"冻结"时,程序还未对 out_val 变量赋值,因此看到第一次获取生成器的值为0。
9.  提示：通过上面的执行过程不难看出,生成器根本不能获取第一次调用send()方法发送的参数值,
这就是Python 要求生成器第一次调用send()方法时只能发送None 参数的原因。
10. 接下来程序调用next(sg)获取生成器的下一个值,程序从"冻结"处(对 out_val 赋值)向下执行。
由于此处调用next()函数获取生成器的下一个值,因此 out_val 被赋值为None, 所以程序执 行 yieldi**2 (生成器返回1),程序再次被"冻结"。
11. 接下来程序调用sg.send(9)获取生成器的下一个值,程序从"冻结"处(对 out_val 赋值)向下 执行。
由于此处调用send(9)方法获取生成器的下一个值,因此out val被赋值为9,所以程序执行 yield out val**2 (生成器返回81),程序再次被"冻结"。
因此看到本次获取生成器的值为81。
12. 程序再次调用next(sg)获取生成器的下一个值,程序从"冻结"处(对 out_val 赋值)向下执行。
由于此处调用next()函数获取生成器的下一个值,因此 out_val 被赋值为None, 所以程序执行 yieldi**2 (此时i已经递增到3,因此生成器返回9),
程序再次被"冻结"。因此看到本次获取生 成器的值为9。
13. 此外,生成器还提供了如下两个常用方法。
(1)close(): 该方法用于停止生成器。
(2)throw()：该方法用于在生成器内部 (yield语句内)引发一个异常。
例如,在程序中增加如下代码。
"""


def square_gen(val):
    i = 0
    out_val = None
    while True:
        # 使用yield语句生成值,使用out_val接收send()方法发送的参数值
        out_val = (yield out_val ** 2) if out_val is not None else (yield i ** 2)
        # 如果程序使用send()方法获取下一个值,out_val会获取send()方法的参数
        if out_val is not None: print("====%d" % out_val)
        i += 1


sg = square_gen(5)
# 第一次调用send()方法获取值,只能传入None作为参数
print(sg.send(None))  # 0
print(next(sg))  # 1
print('--------------')
# 调用send()方法获取生成器的下一个值,参数9会被发送给生成器
print(sg.send(9))  # 81
# 再次调用next()函数获取生成器的下一个值
print(next(sg))  # 9

# 让生成器引发异常
# sg.throw(ValueError)

# 关闭生成器
sg.close()
print(next(sg))  # StopIteration
