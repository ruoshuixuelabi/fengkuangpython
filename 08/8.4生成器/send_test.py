"""
8.4.2 生成器的方法

当生成器运行起来之后,开发者还可以为生成器提供值,通过这种方式让生成器与"外部程序" 动态地交换数据。

为了实现生成器与"外部程序"动态地交换数据,需要借助于生成器的 send()方法,该方法的功能与前面示例中所使用的 next()
函数的功能非常相似,它们都用于获取生成器所生成的下一个值,并将生成器"冻结"在 yield 语句处;
但 send()方法可以接收一个参数,该参数值会被发送给生成器函数。

在生成器函数内部,程序可通过 yield 表达式来获取 send()方法所发送的值——这意味着此时程序应该使用一个变量来接收 yield语句的值。
如果程序依然使用 next()函数来获取生成器所生成的下一个值,那么yield语句返回None。

对于上面详细的描述,归纳起来就是两句话。
(1)外部程序通过send()方法发送数据。
(2)生成器函数使用yield语句接收收据。

另外,需要说明的是,只有等到生成器被"冻结"之后,外部程序才能使用 send()方法向生成器发送数据。
获取生成器第一次所生成的值,应该使用 next()函数;如果程序非要使用 send()方法获取生成器第一次所生成的值,
也不能向生成器发送数据,只能为该方法传入None 参数。

下面程序示范了向生成器发送数据。该程序会依次生成每个整数的平方值,但外部程序可以向生成器发送数据,
当生成器接收到外部数据之后会生成外部数据的平方值。
"""


def square_gen(val):
    i = 0
    out_val = None
    while True:
        # 使用yield语句生成值,使用out_val接收send()方法发送的参数值
        out_val = (yield out_val ** 2) if out_val is not None else (yield i ** 2)
        # 如果程序使用send()方法获取下一个值,out_val会获取send()方法的参数
        if out_val is not None: print("====%d" % out_val)
        i += 1


sg = square_gen(5)
# 第一次调用send()方法获取值,只能传入None作为参数
print(sg.send(None))  # 0
print(next(sg))  # 1
print('--------------')
# 调用send()方法获取生成器的下一个值,参数9会被发送给生成器
print(sg.send(9))  # 81
# 再次调用next()函数获取生成器的下一个值
print(next(sg))  # 9
"""
该程序与前面的简单生成器程序的区别就在于粗体字代码行,这行代码在yield语句(yield语句被放在if表达式中,
整个表达式只会返回一个yield语句)的左边放了一个变量,该变量就用于接收生成器send()方法所发送的值。

上面程序第一次使用生成器的send()方法来获取生成器的下一个值,因此只能为send()方法传入None 作为参数。
程序执行到粗体字代码处,由于此时 out_val 为 None, 因此程序执行yield i ** 2(生成器返回0),程序被"冻结" — —
注意,当程序被"冻结"时,程序还未对 out_val 变量赋值,因此看到第一次获取生成器的值为0。

提示：通过上面的执行过程不难看出,生成器根本不能获取第一次调用send()方法发送的参数值,
这就是Python 要求生成器第一次调用send()方法时只能发送None 参数的原因。

接下来程序调用next(sg)获取生成器的下一个值,程序从"冻结"处(对 out_val 赋值)向下执行。
由于此处调用next()函数获取生成器的下一个值,因此 out_val 被赋值为None, 所以程序执行 yield i ** 2 (生成器返回1),程序再次被"冻结"。

接下来程序调用sg.send(9)获取生成器的下一个值,程序从"冻结"处(对 out_val 赋值)向下执行。
由于此处调用send(9)方法获取生成器的下一个值,因此 out_val 被赋值为9,所以程序执行 yield out_val ** 2 (生成器返回81),程序再次被"冻结"。
因此看到本次获取生成器的值为81。

程序再次调用next(sg)获取生成器的下一个值,程序从"冻结"处(对 out_val 赋值)向下执行。
由于此处调用next()函数获取生成器的下一个值,因此 out_val 被赋值为None,所以程序执行 yield i ** 2 (此时i已经递增到3,因此生成器返回9),
程序再次被"冻结"。因此看到本次获取生成器的值为9。

此外,生成器还提供了如下两个常用方法。
(1)close()：该方法用于停止生成器。
(2)throw()：该方法用于在生成器内部(yield语句内)引发一个异常。

例如,在程序中增加如下代码。
"""
# 让生成器引发异常
# sg.throw(ValueError)
"""
运行上面代码,将看到如下输出结果。

Traceback (most recent call last):
  File "D:send_test.py", line 75, in <module>
    sg.throw(ValueError)
  File "D:send_test.py", line 31, in square_gen
    out_val = (yield out_val ** 2) if out_val is not None else (yield i ** 2)
ValueError

从上面的输出结果可以看到,在程序调用生成器的 throw()方法引发异常之后,程序就会在 yield 语句中引发该异常。
将上面的 sg.throw(ValueError) 代码注释掉,为程序增加如下两行代码来示范 close() 方法的用法。
在程序调用 close()方法关闭生成器之后,程序就不能再去获取生成器的下一个值,否则就会引发异常。
"""
# 关闭生成器
sg.close()
print(next(sg))  # StopIteration
